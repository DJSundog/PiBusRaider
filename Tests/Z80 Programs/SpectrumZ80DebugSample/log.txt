CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // WPMEM
                // Finishes off the loading of the list and labels files
                labels_1.Labels.finish();
                // convert labels in watchpoints.
                const watchpoints = new Array();
                for (let entry of watchPointLines) {
                    // WPMEM:
                    // Syntax:
                    // WPMEM [addr [, length [, access]]]
                    // with:
                    //	addr = address (or label) to observe (optional). Defaults to current address.
                    //	length = the count of bytes to observe (optional). Default = 1.
                    //	access = Read/write access. Possible values: r, w or rw. Defaults to rw.
                    // e.g. WPMEM LBL_TEXT, 1, w
                    // or
                    // WPMEM ,1,w, MWV&B8h/0
                    // Now check more thoroughly: group1=address, group3=length, group5=access, group7=condition
                    const match = /;.*WPMEM(?=[,\s]|$)\s*([^\s,]*)?(\s*,\s*([^\s,]*)(\s*,\s*([^\s,]*)(\s*,\s*([^,]*))?)?)?/.exec(entry.line);
                    if (match) {
                        // get arguments
                        let addressString = match[1];
                        let lengthString = match[3];
                        let access = match[5];
                        let cond = match[7]; // This is supported only with "fast-breakpoints" not with the unmodified ZEsarUX. Also the new (7.1) faster memory breakpoints do not support conditions.
                        // defaults
                        let entryAddress = entry.address;
                        if (addressString && addressString.length > 0)
                            entryAddress = labels_1.Labels.getNumberFromString(addressString);
                        if (isNaN(entryAddress))
                            continue; // could happen if the WPMEM is in an area that is conditionally not compiled, i.e. label does not exist.
                        let length = 1;
                        if (lengthString && lengthString.length > 0) {
                            length = labels_1.Labels.getNumberFromString(lengthString) || NaN;
                            if (isNaN(length))
                                continue;
                        }
                        else {
                            if (!addressString || addressString.length == 0) {
                                // If both, address and length are not defined it is checked
                                // if there exists bytes in the list file (i.e.
                                // numbers after the address field.
                                // If not the "WPMEM" is assumed to be inside a
                                // macro and omitted.
                                const match = /^[0-9a-f]+\s[0-9a-f]+/i.exec(entry.line);
                                if (!match)
                                    continue;
                            }
                        }
                        if (access && access.length > 0) {
                            if (access != 'r' && access != 'w' && access != 'rw') {
                                this.showWarning("Wrong access mode in watch point. Allowed are only 'r', 'w' or 'rw' but found '" + access + "' in line: '" + entry.line + "'");
                                continue;
                            }
                        }
                        else
                            access = 'rw';
                        // set watchpoint
                        watchpoints.push({ address: entryAddress, size: length, access: access, conditions: cond || '' });
                    }
                }
                // Set watchpoints (memory guards)
                emulatorfactory_1.Emulator.setWPMEM(watchpoints);
                // "Return"
                this.serializer.endExec();
            }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // WPMEM
                // Finishes off the loading of the list and labels files
                labels_1.Labels.finish();
                // convert labels in watchpoints.
                const watchpoints = new Array();
                for (let entry of watchPointLines) {
                    // WPMEM:
                    // Syntax:
                    // WPMEM [addr [, length [, access]]]
                    // with:
                    //	addr = address (or label) to observe (optional). Defaults to current address.
                    //	length = the count of bytes to observe (optional). Default = 1.
                    //	access = Read/write access. Possible values: r, w or rw. Defaults to rw.
                    // e.g. WPMEM LBL_TEXT, 1, w
                    // or
                    // WPMEM ,1,w, MWV&B8h/0
                    // Now check more thoroughly: group1=address, group3=length, group5=access, group7=condition
                    const match = /;.*WPMEM(?=[,\s]|$)\s*([^\s,]*)?(\s*,\s*([^\s,]*)(\s*,\s*([^\s,]*)(\s*,\s*([^,]*))?)?)?/.exec(entry.line);
                    if (match) {
                        // get arguments
                        let addressString = match[1];
                        let lengthString = match[3];
                        let access = match[5];
                        let cond = match[7]; // This is supported only with "fast-breakpoints" not with the unmodified ZEsarUX. Also the new (7.1) faster memory breakpoints do not support conditions.
                        // defaults
                        let entryAddress = entry.address;
                        if (addressString && addressString.length > 0)
                            entryAddress = labels_1.Labels.getNumberFromString(addressString);
                        if (isNaN(entryAddress))
                            continue; // could happen if the WPMEM is in an area that is conditionally not compiled, i.e. label does not exist.
                        let length = 1;
                        if (lengthString && lengthString.length > 0) {
                            length = labels_1.Labels.getNumberFromString(lengthString) || NaN;
                            if (isNaN(length))
                                continue;
                        }
                        else {
                            if (!addressString || addressString.length == 0) {
                                // If both, address and length are not defined it is checked
                                // if there exists bytes in the list file (i.e.
                                // numbers after the address field.
                                // If not the "WPMEM" is assumed to be inside a
                                // macro and omitted.
                                const match = /^[0-9a-f]+\s[0-9a-f]+/i.exec(entry.line);
                                if (!match)
                                    continue;
                            }
                        }
                        if (access && access.length > 0) {
                            if (access != 'r' && access != 'w' && access != 'rw') {
                                this.showWarning("Wrong access mode in watch point. Allowed are only 'r', 'w' or 'rw' but found '" + access + "' in line: '" + entry.line + "'");
                                continue;
                            }
                        }
                        else
                            access = 'rw';
                        // set watchpoint
                        watchpoints.push({ address: entryAddress, size: length, access: access, conditions: cond || '' });
                    }
                }
                // Set watchpoints (memory guards)
                emulatorfactory_1.Emulator.setWPMEM(watchpoints);
                // "Return"
                this.serializer.endExec();
            }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // ASSERTs
                const assertMap = new Map();
                // Convert ASSERTS to watchpoints
                for (let entry of assertLines) {
                    // ASSERT:
                    // Syntax:
                    // ASSERT var comparison expr [&&|| var comparison expr]
                    // with:
                    //  var: a variable, i.e. a register like A or HL
                    //  comparison: one of '<', '>', '==', '!=', '<=', '=>'.
                    //	expr: a mathematical expression that resolves into a constant
                    // Examples:
                    // - ASSERT A < 5
                    // - ASSERT HL <= LBL_END+2
                    // - ASSERT B > (MAX_COUNT+1)/2
                    // ASSERTs are breakpoints with "inverted" condition.
                    // Now check more thoroughly: group1=var, group2=comparison, group3=expression
                    try {
                        const matchAssert = /;.*\bASSERT\b/.exec(entry.line);
                        if (!matchAssert) {
                            // Eg. could be that "ASSERTx" was found.
                            continue;
                        }
                        // Get part of the string after the "ASSERT"
                        const part = entry.line.substr(matchAssert.index + matchAssert[0].length).trim();
                        // Check if no condition was set = ASSERT false = Always break
                        let conds = '';
                        if (part.length > 0) {
                            // Some condition is set
                            const regex = /\s*([a-z]+)\s*([<>=!]+)\s*([^;|&]*)(\|\||&&*)?/gi;
                            let match = regex.exec(part);
                            if (!match) // At least one match should be found
                                throw Error("Expecting 'ASSERT var comparison expr'.");
                            let concatString;
                            while (match) {
                                // Get arguments
                                let varString = match[1] || "";
                                varString = varString.trim();
                                let compString = match[2] || "";
                                compString = compString.trim();
                                let exprString = match[3] || "";
                                exprString = exprString.trim();
                                concatString = match[4] || "";
                                concatString = concatString.trim();
                                // Check and "invert" the assert condition.
                                // Check register / variable
                                if (!z80Registers_1.Z80Registers.isRegister(varString))
                                    throw Error("Don't know '" + varString + "'");
                                // Convert to a number
                                const exprValue = utility_1.Utility.evalExpression(exprString, false); // don't evaluate registers
                                // Check comparison
                                let resComp;
                                if (compString.length > 0) {
                                    // The ASSERT condition needs to be negated for the breakpoint.
                                    switch (compString) {
                                        // >= :
                                        case '<':
                                            resComp = '>=';
                                            break;
                                        // <= :
                                        case '>':
                                            resComp = '<=';
                                            break;
                                        // > :
                                        case '<=':
                                            resComp = '>';
                                            break;
                                        // < :
                                        case '>=':
                                            resComp = '<';
                                            break;
                                        // != :
                                        case '==':
                                            resComp = '!=';
                                            break;
                                        // == :
                                        case '!=':
                                            resComp = '==';
                                            break;
                                    }
                                }
                                if (!resComp)
                                    throw Error("Don't know comparison '" + compString + "'");
                                // Check concatenation
                                let resConcat = '';
                                if (concatString.length > 0) {
                                    // Invert
                                    if (concatString == "&&")
                                        resConcat = "||";
                                    else if (concatString == "||")
                                        resConcat = "&&";
                                    else
                                        throw Error("Cannot handle concatenation with '" + concatString + "'. Use '&&' or '||' instead.");
                                    resConcat = ' ' + resConcat;
                                }
                                // Now create condition for zesarux.
                                const condPart = varString + ' ' + resComp + ' ' + exprValue.toString();
                                if (conds.length > 0)
                                    conds += ' ';
                                conds += condPart + resConcat;
                                // Next
                                match = regex.exec(part);
                            }
                            // Check
                            if (concatString.length > 0) // has to end without concatenation symbol
                                throw Error("Expected condition after concatenation symbol '" + concatString + "'");
                        }
                        // Check if ASSERT for that address already exists.
                        let bp = assertMap.get(entry.address);
                        if (bp && conds.length > 0) {
                            // Already exists: just add condition.
                            // Check that 2nd condition is not too complicated.
                            if (conds.indexOf("&&") >= 0)
                                throw Error("Condition too complicated. 2 ASSERTs at the same address are combined and the 2nd condition must not include a '||' condition.");
                            // Concatenate conditions.
                            bp.conditions += ' || ' + conds;
                        }
                        else {
                            // Breakpoint for address does not yet exist. Create a new one.
                            const assertBp = { address: entry.address, size: 1, access: "p", conditions: conds || '' };
                            assertMap.set(entry.address, assertBp);
                        }
                    }
                    catch (e) {
                        vscode.window.showWarningMessage("Problem with ASSERT. Could not evaluate: '" + entry.line + "': " + e + "");
                    }
                }
                // Convert map to array.
                const assertsArray = Array.from(assertMap.values());
                // Set assert breakpoints
                emulatorfactory_1.Emulator.setASSERT(assertsArray);
                // "Return"
                this.serializer.endExec();
            }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // ASSERTs
                const assertMap = new Map();
                // Convert ASSERTS to watchpoints
                for (let entry of assertLines) {
                    // ASSERT:
                    // Syntax:
                    // ASSERT var comparison expr [&&|| var comparison expr]
                    // with:
                    //  var: a variable, i.e. a register like A or HL
                    //  comparison: one of '<', '>', '==', '!=', '<=', '=>'.
                    //	expr: a mathematical expression that resolves into a constant
                    // Examples:
                    // - ASSERT A < 5
                    // - ASSERT HL <= LBL_END+2
                    // - ASSERT B > (MAX_COUNT+1)/2
                    // ASSERTs are breakpoints with "inverted" condition.
                    // Now check more thoroughly: group1=var, group2=comparison, group3=expression
                    try {
                        const matchAssert = /;.*\bASSERT\b/.exec(entry.line);
                        if (!matchAssert) {
                            // Eg. could be that "ASSERTx" was found.
                            continue;
                        }
                        // Get part of the string after the "ASSERT"
                        const part = entry.line.substr(matchAssert.index + matchAssert[0].length).trim();
                        // Check if no condition was set = ASSERT false = Always break
                        let conds = '';
                        if (part.length > 0) {
                            // Some condition is set
                            const regex = /\s*([a-z]+)\s*([<>=!]+)\s*([^;|&]*)(\|\||&&*)?/gi;
                            let match = regex.exec(part);
                            if (!match) // At least one match should be found
                                throw Error("Expecting 'ASSERT var comparison expr'.");
                            let concatString;
                            while (match) {
                                // Get arguments
                                let varString = match[1] || "";
                                varString = varString.trim();
                                let compString = match[2] || "";
                                compString = compString.trim();
                                let exprString = match[3] || "";
                                exprString = exprString.trim();
                                concatString = match[4] || "";
                                concatString = concatString.trim();
                                // Check and "invert" the assert condition.
                                // Check register / variable
                                if (!z80Registers_1.Z80Registers.isRegister(varString))
                                    throw Error("Don't know '" + varString + "'");
                                // Convert to a number
                                const exprValue = utility_1.Utility.evalExpression(exprString, false); // don't evaluate registers
                                // Check comparison
                                let resComp;
                                if (compString.length > 0) {
                                    // The ASSERT condition needs to be negated for the breakpoint.
                                    switch (compString) {
                                        // >= :
                                        case '<':
                                            resComp = '>=';
                                            break;
                                        // <= :
                                        case '>':
                                            resComp = '<=';
                                            break;
                                        // > :
                                        case '<=':
                                            resComp = '>';
                                            break;
                                        // < :
                                        case '>=':
                                            resComp = '<';
                                            break;
                                        // != :
                                        case '==':
                                            resComp = '!=';
                                            break;
                                        // == :
                                        case '!=':
                                            resComp = '==';
                                            break;
                                    }
                                }
                                if (!resComp)
                                    throw Error("Don't know comparison '" + compString + "'");
                                // Check concatenation
                                let resConcat = '';
                                if (concatString.length > 0) {
                                    // Invert
                                    if (concatString == "&&")
                                        resConcat = "||";
                                    else if (concatString == "||")
                                        resConcat = "&&";
                                    else
                                        throw Error("Cannot handle concatenation with '" + concatString + "'. Use '&&' or '||' instead.");
                                    resConcat = ' ' + resConcat;
                                }
                                // Now create condition for zesarux.
                                const condPart = varString + ' ' + resComp + ' ' + exprValue.toString();
                                if (conds.length > 0)
                                    conds += ' ';
                                conds += condPart + resConcat;
                                // Next
                                match = regex.exec(part);
                            }
                            // Check
                            if (concatString.length > 0) // has to end without concatenation symbol
                                throw Error("Expected condition after concatenation symbol '" + concatString + "'");
                        }
                        // Check if ASSERT for that address already exists.
                        let bp = assertMap.get(entry.address);
                        if (bp && conds.length > 0) {
                            // Already exists: just add condition.
                            // Check that 2nd condition is not too complicated.
                            if (conds.indexOf("&&") >= 0)
                                throw Error("Condition too complicated. 2 ASSERTs at the same address are combined and the 2nd condition must not include a '||' condition.");
                            // Concatenate conditions.
                            bp.conditions += ' || ' + conds;
                        }
                        else {
                            // Breakpoint for address does not yet exist. Create a new one.
                            const assertBp = { address: entry.address, size: 1, access: "p", conditions: conds || '' };
                            assertMap.set(entry.address, assertBp);
                        }
                    }
                    catch (e) {
                        vscode.window.showWarningMessage("Problem with ASSERT. Could not evaluate: '" + entry.line + "': " + e + "");
                    }
                }
                // Convert map to array.
                const assertsArray = Array.from(assertMap.values());
                // Set assert breakpoints
                emulatorfactory_1.Emulator.setASSERT(assertsArray);
                // "Return"
                this.serializer.endExec();
            }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // Create memory/register dump view
                let registerMemoryView = new memoryregisterview_1.MemoryRegisterView(this);
                const regs = settings_1.Settings.launch.memoryViewer.registersMemoryView;
                registerMemoryView.addRegisters(regs);
                registerMemoryView.update();
                // "Return"
                this.serializer.endExec();
            }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // Create memory/register dump view
                let registerMemoryView = new memoryregisterview_1.MemoryRegisterView(this);
                const regs = settings_1.Settings.launch.memoryViewer.registersMemoryView;
                registerMemoryView.addRegisters(regs);
                registerMemoryView.update();
                // "Return"
                this.serializer.endExec();
            }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // Socket is connected, allow setting breakpoints
                this.sendEvent(new main_1.InitializedEvent());
                this.serializer.endExec();
                // Respond
                handler();
            }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendEvent:  <-: initialized(undefined)
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // Socket is connected, allow setting breakpoints
                this.sendEvent(new main_1.InitializedEvent());
                this.serializer.endExec();
                // Respond
                handler();
            }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
EmulDebugAdapter.sendResponse:  <-: launch(undefined)
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // Check if program should be automatically started
                if (settings_1.Settings.launch.startAutomatically) {
                    // The ContinuedEvent is necessary in case vscode was stopped and a restart is done. Without, vscode would stay stopped.
                    this.sendEvent(new main_1.ContinuedEvent(EmulDebugAdapter.THREAD_ID));
                    setTimeout(() => {
                        // Delay call because the breakpoints are set afterwards.
                        this.emulatorContinue();
                    }, 500);
                }
                else {
                    this.sendEvent(new main_1.StoppedEvent('stop on start', EmulDebugAdapter.THREAD_ID));
                }
                this.serializer.endExec();
            }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendEvent:  <-: continued({"threadId":1})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // Check if program should be automatically started
                if (settings_1.Settings.launch.startAutomatically) {
                    // The ContinuedEvent is necessary in case vscode was stopped and a restart is done. Without, vscode would stay stopped.
                    this.sendEvent(new main_1.ContinuedEvent(EmulDebugAdapter.THREAD_ID));
                    setTimeout(() => {
                        // Delay call because the breakpoints are set afterwards.
                        this.emulatorContinue();
                    }, 500);
                }
                else {
                    this.sendEvent(new main_1.StoppedEvent('stop on start', EmulDebugAdapter.THREAD_ID));
                }
                this.serializer.endExec();
            }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=3, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=4, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=5, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=6, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
EmulDebugAdapter.dispatchRequest:  ->: setBreakpoints({"source":{"name":"clearscreen.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\clearscreen.asm"},"lines":[18],"breakpoints":[{"line":18}],"sourceModified":false})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            const path = args.source.path;
            // convert breakpoints
            const givenBps = args.breakpoints || [];
            const bps = givenBps.map(bp => {
                var mbp;
                mbp = {
                    bpId: 0,
                    filePath: path,
                    lineNr: this.convertClientLineToDebugger(bp.line),
                    address: -1,
                    condition: (bp.condition) ? bp.condition : ''
                };
                return mbp;
            });
            // Set breakpoints for the file.
            emulatorfactory_1.Emulator.setBreakpoints(path, bps, currentBreakpoints => {
                /*
                // Go through original list of vscode breakpoints and check if they are verified or not
                let source = this.createSource(path);
                const vscodeBreakpoints = givenBps.map(gbp => {
                    let verified = false;
                    // Check if breakpoint is present in currentBreakpoints
                    const lineNr = this.convertClientLineToDebugger(gbp.line);
                    for(let cbp of currentBreakpoints) {
                        if(cbp.lineNr == lineNr && cbp.filePath == path) {
                            verified = true;
                            break;
                        }
                    }
                    // Create new breakpoint
                    let bp = new Breakpoint(verified, gbp.line, gbp.column, source);
                    return bp;
                });
                */
                const source = this.createSource(path);
                const vscodeBreakpoints = currentBreakpoints.map(cbp => {
                    const lineNr = this.convertDebuggerLineToClient(cbp.lineNr);
                    const verified = (cbp.address >= 0); // Is not verified if no address is set
                    let bp = new main_1.Breakpoint(verified, lineNr, 0, source);
                    return bp;
                });
                // send back the actual breakpoint positions
                response.body = {
                    breakpoints: vscodeBreakpoints
                };
                this.sendResponse(response);
                this.serializer.endExec();
            }, 
            // Handle temporary disassembler breakpoints
            (bp) => {
                // Check if it is the right path
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                if (bp.filePath == absFilePath) {
                    // Get address from line number
                    const lines = this.dasm.getDisassemblyLines();
                    const lineCount = lines.length;
                    let lineNr = bp.lineNr;
                    while (lineNr < lineCount) {
                        const line = lines[lineNr];
                        const addr = parseInt(line, 16);
                        if (!isNaN(addr)) {
                            // create breakpoint object
                            const ebp = { bpId: 0, filePath: bp.filePath, lineNr: lineNr, address: addr, condition: bp.condition };
                            return ebp;
                        }
                        lineNr++;
                    }
                }
                return undefined;
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Do most of the work
            super.setBreakpoints(path, givenBps, bps => {
                // But wait for the socket.
                zesaruxSocket_1.zSocket.executeWhenQueueIsEmpty(() => {
                    handler(bps);
                    // End
                    this.serializer.endExec();
                });
            }, tmpDisasmFileHandler);
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=5, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.sendResponse:  <-: setBreakpoints({"breakpoints":[{"verified":false,"line":18,"column":0,"source":{"name":"clearscreen.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\clearscreen.asm","sourceReference":0}}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            const path = args.source.path;
            // convert breakpoints
            const givenBps = args.breakpoints || [];
            const bps = givenBps.map(bp => {
                var mbp;
                mbp = {
                    bpId: 0,
                    filePath: path,
                    lineNr: this.convertClientLineToDebugger(bp.line),
                    address: -1,
                    condition: (bp.condition) ? bp.condition : ''
                };
                return mbp;
            });
            // Set breakpoints for the file.
            emulatorfactory_1.Emulator.setBreakpoints(path, bps, currentBreakpoints => {
                /*
                // Go through original list of vscode breakpoints and check if they are verified or not
                let source = this.createSource(path);
                const vscodeBreakpoints = givenBps.map(gbp => {
                    let verified = false;
                    // Check if breakpoint is present in currentBreakpoints
                    const lineNr = this.convertClientLineToDebugger(gbp.line);
                    for(let cbp of currentBreakpoints) {
                        if(cbp.lineNr == lineNr && cbp.filePath == path) {
                            verified = true;
                            break;
                        }
                    }
                    // Create new breakpoint
                    let bp = new Breakpoint(verified, gbp.line, gbp.column, source);
                    return bp;
                });
                */
                const source = this.createSource(path);
                const vscodeBreakpoints = currentBreakpoints.map(cbp => {
                    const lineNr = this.convertDebuggerLineToClient(cbp.lineNr);
                    const verified = (cbp.address >= 0); // Is not verified if no address is set
                    let bp = new main_1.Breakpoint(verified, lineNr, 0, source);
                    return bp;
                });
                // send back the actual breakpoint positions
                response.body = {
                    breakpoints: vscodeBreakpoints
                };
                this.sendResponse(response);
                this.serializer.endExec();
            }, 
            // Handle temporary disassembler breakpoints
            (bp) => {
                // Check if it is the right path
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                if (bp.filePath == absFilePath) {
                    // Get address from line number
                    const lines = this.dasm.getDisassemblyLines();
                    const lineCount = lines.length;
                    let lineNr = bp.lineNr;
                    while (lineNr < lineCount) {
                        const line = lines[lineNr];
                        const addr = parseInt(line, 16);
                        if (!isNaN(addr)) {
                            // create breakpoint object
                            const ebp = { bpId: 0, filePath: bp.filePath, lineNr: lineNr, address: addr, condition: bp.condition };
                            return ebp;
                        }
                        lineNr++;
                    }
                }
                return undefined;
            });
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Do most of the work
            super.setBreakpoints(path, givenBps, bps => {
                // But wait for the socket.
                zesaruxSocket_1.zSocket.executeWhenQueueIsEmpty(() => {
                    handler(bps);
                    // End
                    this.serializer.endExec();
                });
            }, tmpDisasmFileHandler);
        }
CallSerializer.endExec:  Popped (size=4, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=3, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.dispatchRequest:  ->: setExceptionBreakpoints({"filters":[]})
EmulDebugAdapter.sendResponse:  <-: setExceptionBreakpoints(undefined)
CallSerializer.endExec:  Popped (size=2, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.dispatchRequest:  ->: threads(undefined)
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: threads({"threads":[{"id":1,"name":"thread_default"}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
...
Pause for 31.479 secs.
...
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
...
Pause for 2.994 secs.
...
EmulDebugAdapter.dispatchRequest:  ->: pause({"threadId":1})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Pause the debugger
            emulatorfactory_1.Emulator.pause();
            // Response is sent immediately
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: pause(undefined)
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Pause the debugger
            emulatorfactory_1.Emulator.pause();
            // Response is sent immediately
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
EmulDebugAdapter.sendEvent:  <-: stopped({"reason":"break","threadId":1})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=3, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=4, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=5, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=6, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
CallSerializer.endExec:  Popped (size=5, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.dispatchRequest:  ->: threads(undefined)
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: threads({"threads":[{"id":1,"name":"thread_default"}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=4, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
                if (!doDisassembly) {
                    // No disassembly required.
                    this.serializer.endExec();
                    return;
                }
                // Create text document
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const uri = vscode.Uri.file(absFilePath);
                const editCreate = new vscode.WorkspaceEdit();
                editCreate.createFile(uri, { overwrite: true });
                vscode.workspace.applyEdit(editCreate).then(() => {
                    vscode.workspace.openTextDocument(absFilePath).then(textDoc => {
                        // Store uri
                        this.disasmTextDoc = textDoc;
                        // End
                        this.serializer.endExec();
                    });
                });
            }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 2
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=3, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 3
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=4, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 4
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
CommandEntry.emulator_1.EmulatorClass.stackTraceRequest.handler.getRegisters.zesaruxSocket_1.zSocket.send.data:  Call stack: 6020H 607CH 
CallSerializer.endExec:  Popped (size=3, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=3, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 3
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=2, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
CallSerializer.endExec:  Popped (size=2, name=undefined), () => {
                if (!doDisassembly) {
                    // No disassembly required.
                    this.serializer.endExec();
                    return;
                }
                // Create text document
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const uri = vscode.Uri.file(absFilePath);
                const editCreate = new vscode.WorkspaceEdit();
                editCreate.createFile(uri, { overwrite: true });
                vscode.workspace.applyEdit(editCreate).then(() => {
                    vscode.workspace.openTextDocument(absFilePath).then(textDoc => {
                        // Store uri
                        this.disasmTextDoc = textDoc;
                        // End
                        this.serializer.endExec();
                    });
                });
            }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 2
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":14,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":25,"column":0,"name":"CALL fill_memory"},{"id":3,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":109,"column":0,"name":"CALL fill_bckg_line"}],"totalFrames":1})
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":14,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":25,"column":0,"name":"CALL fill_memory"},{"id":3,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":109,"column":0,"name":"CALL fill_bckg_line"}],"totalFrames":1})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
EmulDebugAdapter.dispatchRequest:  ->: scopes({"frameId":1})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
EmulDebugAdapter.sendResponse:  <-: scopes({"scopes":[{"name":"Registers","variablesReference":1,"expensive":false},{"name":"Registers 2","variablesReference":2,"expensive":false},{"name":"Disassembly","variablesReference":3,"expensive":false},{"name":"Stack","variablesReference":4,"expensive":false}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
EmulDebugAdapter.dispatchRequest:  ->: variables({"variablesReference":1})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Check if object exists
            if (!varObj) {
                // Return empty list
                var variables = new Array();
                response.body = { variables: variables };
                this.sendResponse(response);
                // end the serialized call:
                this.serializer.endExec();
                return;
            }
            // Get contents
            varObj.getContent((varList) => {
                response.body = { variables: varList };
                this.sendResponse(response);
                // end the serialized call:
                this.serializer.endExec();
            }, args.start, args.count);
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=2, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=3, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=4, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=5, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=6, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=7, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=8, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=9, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=10, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=11, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=12, name=undefined), () => {
                handler(registers);
                innerSerializer.endExec();
            }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=11, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=10, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=9, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=8, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=7, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=6, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=5, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=4, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=3, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=2, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
EmulDebugAdapter.sendResponse:  <-: variables({"variables":[{"name":"PC","type":"6015h, 24597u, fill_memory+5","value":"6015h, 24597u, fill_memory+5","variablesReference":0},{"name":"SP","type":"6099h, 24729u, stack_bottom+16","value":"6099h, 24729u, stack_bottom+16","variablesReference":0},{"name":"A","type":"10h, 16u, 16i, '.', 00010000","value":"10h, 16u, 16i, '.', 00010000","variablesReference":0},{"name":"F","type":"ZP","value":"ZP","variablesReference":0},{"name":"HL","type":"(5A99h)b=16, 23193u, 23193i, COLOR_SCREEN+665","value":"(5A99h)b=16, 23193u, 23193i, COLOR_SCREEN+665","variablesReference":0},{"name":"DE","type":"5A9Ah, 23194u, 23194i, COLOR_SCREEN+666","value":"5A9Ah, 23194u, 23194i, COLOR_SCREEN+666","variablesReference":0},{"name":"BC","type":"0006h, 6u, 6i","value":"0006h, 6u, 6i","variablesReference":0},{"name":"IX","type":"663Ch, 26172u, 26172i, stack_top+1439","value":"663Ch, 26172u, 26172i, stack_top+1439","variablesReference":0},{"name":"IY","type":"5C3Ah, 23610u, 23610i, COLOR_SCREEN+1082","value":"5C3Ah, 23610u, 23610i, COLOR_SCREEN+1082","variablesReference":0},{"name":"B","type":"00h, 0u, 0i, '0̲', 00000000","value":"00h, 0u, 0i, '0̲', 00000000","variablesReference":0},{"name":"C","type":"06h, 6u, 6i, '.', 00000110","value":"06h, 6u, 6i, '.', 00000110","variablesReference":0},{"name":"D","type":"5Ah, 90u, 90i, 'Z', 01011010","value":"5Ah, 90u, 90i, 'Z', 01011010","variablesReference":0},{"name":"E","type":"9Ah, 154u, -102i, '.', 10011010","value":"9Ah, 154u, -102i, '.', 10011010","variablesReference":0},{"name":"H","type":"5Ah, 90u, 90i, 'Z', 01011010","value":"5Ah, 90u, 90i, 'Z', 01011010","variablesReference":0},{"name":"L","type":"99h, 153u, -103i, '.', 10011001","value":"99h, 153u, -103i, '.', 10011001","variablesReference":0}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Check if object exists
            if (!varObj) {
                // Return empty list
                var variables = new Array();
                response.body = { variables: variables };
                this.sendResponse(response);
                // end the serialized call:
                this.serializer.endExec();
                return;
            }
            // Get contents
            varObj.getContent((varList) => {
                response.body = { variables: varList };
                this.sendResponse(response);
                // end the serialized call:
                this.serializer.endExec();
            }, args.start, args.count);
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                handler(registers);
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
EmulDebugAdapter.dispatchRequest:  ->: next({"threadId":1})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Step-Over
            emulatorfactory_1.Emulator.stepOver((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepOver: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: next(undefined)
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Step-Over
            emulatorfactory_1.Emulator.stepOver((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepOver: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
EmulDebugAdapter.sendEvent:  <-: stopped({"reason":"step","threadId":1})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=3, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=4, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=5, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=6, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
CallSerializer.endExec:  Popped (size=5, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.dispatchRequest:  ->: threads(undefined)
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: threads({"threads":[{"id":1,"name":"thread_default"}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=4, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 2
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=3, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 3
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
CommandEntry.emulator_1.EmulatorClass.stackTraceRequest.handler.getRegisters.zesaruxSocket_1.zSocket.send.data:  Call stack: 6020H 607CH 
CallSerializer.endExec:  Popped (size=3, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=2, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":15,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":25,"column":0,"name":"CALL fill_memory"},{"id":3,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":109,"column":0,"name":"CALL fill_bckg_line"}],"totalFrames":1})
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":15,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":25,"column":0,"name":"CALL fill_memory"},{"id":3,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":109,"column":0,"name":"CALL fill_bckg_line"}],"totalFrames":1})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=2, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
EmulDebugAdapter.dispatchRequest:  ->: next({"threadId":1})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Step-Over
            emulatorfactory_1.Emulator.stepOver((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepOver: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: next(undefined)
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Step-Over
            emulatorfactory_1.Emulator.stepOver((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepOver: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
EmulDebugAdapter.sendEvent:  <-: stopped({"reason":"step","threadId":1})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=3, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=4, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=5, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=6, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
CallSerializer.endExec:  Popped (size=5, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.dispatchRequest:  ->: threads(undefined)
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: threads({"threads":[{"id":1,"name":"thread_default"}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
EmulDebugAdapter.dispatchRequest:  ->: scopes({"frameId":1})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
EmulDebugAdapter.sendResponse:  <-: scopes({"scopes":[{"name":"Registers","variablesReference":1,"expensive":false},{"name":"Registers 2","variablesReference":2,"expensive":false},{"name":"Disassembly","variablesReference":3,"expensive":false},{"name":"Stack","variablesReference":4,"expensive":false}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=4, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 2
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=3, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 3
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
EmulDebugAdapter.dispatchRequest:  ->: next({"threadId":1})
CallSerializer.exec:  Pushed (size=4, name=undefined), () => {
            // Step-Over
            emulatorfactory_1.Emulator.stepOver((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepOver: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 4
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CommandEntry.emulator_1.EmulatorClass.stackTraceRequest.handler.getRegisters.zesaruxSocket_1.zSocket.send.data:  Call stack: 607CH 
CallSerializer.endExec:  Popped (size=3, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=3, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=2, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":26,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":109,"column":0,"name":"CALL fill_bckg_line"}],"totalFrames":1})
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":26,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":109,"column":0,"name":"CALL fill_bckg_line"}],"totalFrames":1})
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: next({"threadId":1})
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
            // Step-Over
            emulatorfactory_1.Emulator.stepOver((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepOver: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 2
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: next(undefined)
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
            // Step-Over
            emulatorfactory_1.Emulator.stepOver((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepOver: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendEvent:  <-: stopped({"reason":"step","threadId":1})
CallSerializer.exec:  Pushed (size=4, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=5, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=6, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=7, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=8, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=9, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
EmulDebugAdapter.dispatchRequest:  ->: scopes({"frameId":1})
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 2
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: threads(undefined)
CallSerializer.exec:  Pushed (size=3, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 3
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: next(undefined)
CallSerializer.endExec:  Popped (size=2, name=undefined), () => {
            // Step-Over
            emulatorfactory_1.Emulator.stepOver((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepOver: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
EmulDebugAdapter.sendResponse:  <-: scopes({"scopes":[{"name":"Registers","variablesReference":1,"expensive":false},{"name":"Registers 2","variablesReference":2,"expensive":false},{"name":"Disassembly","variablesReference":3,"expensive":false},{"name":"Stack","variablesReference":4,"expensive":false}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: threads({"threads":[{"id":1,"name":"thread_default"}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
EmulDebugAdapter.sendEvent:  <-: stopped({"reason":"step","threadId":1})
CallSerializer.exec:  Pushed (size=10, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=11, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=12, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=13, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=14, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=15, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
CallSerializer.endExec:  Popped (size=14, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 2
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=3, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 3
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
EmulDebugAdapter.dispatchRequest:  ->: next({"threadId":1})
CallSerializer.exec:  Pushed (size=4, name=undefined), () => {
            // Step-Over
            emulatorfactory_1.Emulator.stepOver((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepOver: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 4
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: threads(undefined)
CallSerializer.exec:  Pushed (size=5, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 5
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CommandEntry.emulator_1.EmulatorClass.stackTraceRequest.handler.getRegisters.zesaruxSocket_1.zSocket.send.data:  Call stack: 607CH 
CallSerializer.endExec:  Popped (size=13, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=12, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
CallSerializer.endExec:  Popped (size=4, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=3, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":28,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":109,"column":0,"name":"CALL fill_bckg_line"}],"totalFrames":1})
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":28,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":109,"column":0,"name":"CALL fill_bckg_line"}],"totalFrames":1})
CallSerializer.endExec:  Popped (size=2, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 2
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 2
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 2
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: stepIn({"threadId":1})
CallSerializer.exec:  Pushed (size=3, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 3
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: next(undefined)
CallSerializer.endExec:  Popped (size=2, name=undefined), () => {
            // Step-Over
            emulatorfactory_1.Emulator.stepOver((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepOver: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: threads({"threads":[{"id":1,"name":"thread_default"}]})
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendEvent:  <-: stopped({"reason":"step","threadId":1})
CallSerializer.exec:  Pushed (size=13, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=14, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=15, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=16, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=17, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=18, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
EmulDebugAdapter.dispatchRequest:  ->: scopes({"frameId":1})
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 2
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
CallSerializer.exec:  Pushed (size=3, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 3
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=4, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 4
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=5, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 5
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
EmulDebugAdapter.dispatchRequest:  ->: threads(undefined)
CallSerializer.exec:  Pushed (size=6, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 6
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: stepIn({"threadId":1})
CallSerializer.exec:  Pushed (size=7, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 7
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: stepIn({"threadId":1})
CallSerializer.exec:  Pushed (size=8, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 8
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: stepIn({"threadId":1})
CallSerializer.exec:  Pushed (size=9, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 9
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: stepIn({"threadId":1})
CallSerializer.exec:  Pushed (size=10, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 10
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: stepIn({"threadId":1})
CallSerializer.exec:  Pushed (size=11, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 11
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stepIn(undefined)
CallSerializer.endExec:  Popped (size=10, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
EmulDebugAdapter.sendResponse:  <-: scopes({"scopes":[{"name":"Registers","variablesReference":1,"expensive":false},{"name":"Registers 2","variablesReference":2,"expensive":false},{"name":"Disassembly","variablesReference":3,"expensive":false},{"name":"Stack","variablesReference":4,"expensive":false}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
CallSerializer.endExec:  Popped (size=9, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 9
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 9
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendEvent:  <-: stopped({"reason":"step","threadId":1})
CallSerializer.exec:  Pushed (size=19, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=20, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=21, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=22, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=23, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=24, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
EmulDebugAdapter.dispatchRequest:  ->: threads(undefined)
CallSerializer.exec:  Pushed (size=10, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 10
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=23, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=9, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=8, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":110,"column":0,"name":"PC"}],"totalFrames":1})
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":110,"column":0,"name":"PC"}],"totalFrames":1})
CallSerializer.endExec:  Popped (size=7, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: threads({"threads":[{"id":1,"name":"thread_default"}]})
CallSerializer.endExec:  Popped (size=6, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 6
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 6
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 6
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 6
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
CallSerializer.exec:  Pushed (size=7, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 7
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=8, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 8
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=9, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 9
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
EmulDebugAdapter.dispatchRequest:  ->: scopes({"frameId":1})
CallSerializer.exec:  Pushed (size=10, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 10
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: stepIn({"threadId":1})
CallSerializer.exec:  Pushed (size=11, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 11
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stepIn(undefined)
CallSerializer.endExec:  Popped (size=10, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 10
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendEvent:  <-: stopped({"reason":"step","threadId":1})
CallSerializer.exec:  Pushed (size=24, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=25, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=26, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=27, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=28, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=29, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
EmulDebugAdapter.dispatchRequest:  ->: threads(undefined)
CallSerializer.exec:  Pushed (size=11, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 11
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stepIn(undefined)
CallSerializer.endExec:  Popped (size=10, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 10
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendEvent:  <-: stopped({"reason":"step","threadId":1})
CallSerializer.exec:  Pushed (size=30, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=31, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=32, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=33, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=34, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=35, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
EmulDebugAdapter.dispatchRequest:  ->: threads(undefined)
CallSerializer.exec:  Pushed (size=11, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 11
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stepIn(undefined)
CallSerializer.endExec:  Popped (size=10, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 10
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendEvent:  <-: stopped({"reason":"step","threadId":1})
CallSerializer.exec:  Pushed (size=36, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=37, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=38, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=39, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=40, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=41, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
EmulDebugAdapter.dispatchRequest:  ->: threads(undefined)
CallSerializer.exec:  Pushed (size=11, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 11
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stepIn(undefined)
CallSerializer.endExec:  Popped (size=10, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 10
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendEvent:  <-: stopped({"reason":"step","threadId":1})
CallSerializer.exec:  Pushed (size=42, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=43, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=44, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=45, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=46, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=47, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
EmulDebugAdapter.dispatchRequest:  ->: threads(undefined)
CallSerializer.exec:  Pushed (size=11, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 11
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stepIn(undefined)
CallSerializer.endExec:  Popped (size=10, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: threads({"threads":[{"id":1,"name":"thread_default"}]})
CallSerializer.endExec:  Popped (size=9, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 9
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 9
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendEvent:  <-: stopped({"reason":"step","threadId":1})
CallSerializer.exec:  Pushed (size=48, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=49, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=50, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=51, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=52, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=53, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
EmulDebugAdapter.dispatchRequest:  ->: threads(undefined)
CallSerializer.exec:  Pushed (size=10, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 10
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=52, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=9, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 9
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=51, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=50, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.dispatchRequest:  ->: stepIn({"threadId":1})
CallSerializer.exec:  Pushed (size=10, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 10
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=49, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=48, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
CallSerializer.endExec:  Popped (size=47, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=46, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=45, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=44, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=9, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":114,"column":0,"name":"PC"}],"totalFrames":1})
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":114,"column":0,"name":"PC"}],"totalFrames":1})
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":114,"column":0,"name":"PC"}],"totalFrames":1})
CallSerializer.endExec:  Popped (size=8, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
EmulDebugAdapter.sendResponse:  <-: scopes({"scopes":[{"name":"Registers","variablesReference":1,"expensive":false},{"name":"Registers 2","variablesReference":2,"expensive":false},{"name":"Disassembly","variablesReference":3,"expensive":false},{"name":"Stack","variablesReference":4,"expensive":false}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
CallSerializer.endExec:  Popped (size=7, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 7
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 7
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 7
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: scopes({"frameId":1})
CallSerializer.exec:  Pushed (size=8, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 8
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: stepIn({"threadId":1})
CallSerializer.exec:  Pushed (size=9, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 9
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stepIn(undefined)
CallSerializer.endExec:  Popped (size=8, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: threads({"threads":[{"id":1,"name":"thread_default"}]})
CallSerializer.endExec:  Popped (size=7, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: threads({"threads":[{"id":1,"name":"thread_default"}]})
CallSerializer.endExec:  Popped (size=6, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: threads({"threads":[{"id":1,"name":"thread_default"}]})
CallSerializer.endExec:  Popped (size=5, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: threads({"threads":[{"id":1,"name":"thread_default"}]})
CallSerializer.endExec:  Popped (size=4, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: threads({"threads":[{"id":1,"name":"thread_default"}]})
CallSerializer.endExec:  Popped (size=3, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 3
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 3
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 3
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 3
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 3
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 3
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendEvent:  <-: stopped({"reason":"step","threadId":1})
CallSerializer.exec:  Pushed (size=45, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=46, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=47, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=48, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=49, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=50, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
CallSerializer.exec:  Pushed (size=4, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 4
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=5, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 5
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=6, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 6
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
EmulDebugAdapter.dispatchRequest:  ->: threads(undefined)
CallSerializer.exec:  Pushed (size=7, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 7
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stepIn(undefined)
CallSerializer.endExec:  Popped (size=6, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
EmulDebugAdapter.sendResponse:  <-: scopes({"scopes":[{"name":"Registers","variablesReference":5,"expensive":false},{"name":"Registers 2","variablesReference":6,"expensive":false},{"name":"Disassembly","variablesReference":7,"expensive":false},{"name":"Stack","variablesReference":8,"expensive":false}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
CallSerializer.endExec:  Popped (size=5, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 5
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 5
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendEvent:  <-: stopped({"reason":"step","threadId":1})
CallSerializer.exec:  Pushed (size=51, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=52, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=53, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=54, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=55, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=56, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
EmulDebugAdapter.dispatchRequest:  ->: threads(undefined)
CallSerializer.exec:  Pushed (size=6, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 6
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stepIn(undefined)
CallSerializer.endExec:  Popped (size=5, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 5
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendEvent:  <-: stopped({"reason":"step","threadId":1})
CallSerializer.exec:  Pushed (size=57, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=58, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=59, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=60, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=61, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=62, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
EmulDebugAdapter.dispatchRequest:  ->: threads(undefined)
CallSerializer.exec:  Pushed (size=6, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 6
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CommandEntry.emulator_1.EmulatorClass.stackTraceRequest.handler.getRegisters.zesaruxSocket_1.zSocket.send.data:  Call stack: 6087H 
CallSerializer.endExec:  Popped (size=61, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=60, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
CallSerializer.endExec:  Popped (size=5, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 5
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=59, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=58, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=57, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=56, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=55, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=54, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
CallSerializer.endExec:  Popped (size=53, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=4, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":40,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":114,"column":0,"name":"CALL inc_fill_colors_ptr"}],"totalFrames":1})
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":40,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":114,"column":0,"name":"CALL inc_fill_colors_ptr"}],"totalFrames":1})
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":40,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":114,"column":0,"name":"CALL inc_fill_colors_ptr"}],"totalFrames":1})
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":40,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":114,"column":0,"name":"CALL inc_fill_colors_ptr"}],"totalFrames":1})
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":40,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":114,"column":0,"name":"CALL inc_fill_colors_ptr"}],"totalFrames":1})
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":40,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":114,"column":0,"name":"CALL inc_fill_colors_ptr"}],"totalFrames":1})
CallSerializer.endExec:  Popped (size=3, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: threads({"threads":[{"id":1,"name":"thread_default"}]})
CallSerializer.endExec:  Popped (size=2, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: threads({"threads":[{"id":1,"name":"thread_default"}]})
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: threads({"threads":[{"id":1,"name":"thread_default"}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=52, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 2
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=3, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 3
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
EmulDebugAdapter.dispatchRequest:  ->: scopes({"frameId":1})
CallSerializer.exec:  Pushed (size=4, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 4
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CommandEntry.emulator_1.EmulatorClass.stackTraceRequest.handler.getRegisters.zesaruxSocket_1.zSocket.send.data:  Call stack: 6087H 
CallSerializer.endExec:  Popped (size=51, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=3, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=2, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":40,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":114,"column":0,"name":"CALL inc_fill_colors_ptr"}],"totalFrames":1})
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":40,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":114,"column":0,"name":"CALL inc_fill_colors_ptr"}],"totalFrames":1})
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":40,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":114,"column":0,"name":"CALL inc_fill_colors_ptr"}],"totalFrames":1})
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":40,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":114,"column":0,"name":"CALL inc_fill_colors_ptr"}],"totalFrames":1})
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
EmulDebugAdapter.sendResponse:  <-: scopes({"scopes":[{"name":"Registers","variablesReference":1,"expensive":false},{"name":"Registers 2","variablesReference":2,"expensive":false},{"name":"Disassembly","variablesReference":3,"expensive":false},{"name":"Stack","variablesReference":4,"expensive":false}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=50, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=49, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=48, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
EmulDebugAdapter.dispatchRequest:  ->: scopes({"frameId":1})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
EmulDebugAdapter.sendResponse:  <-: scopes({"scopes":[{"name":"Registers","variablesReference":5,"expensive":false},{"name":"Registers 2","variablesReference":6,"expensive":false},{"name":"Disassembly","variablesReference":7,"expensive":false},{"name":"Stack","variablesReference":8,"expensive":false}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=47, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.dispatchRequest:  ->: variables({"variablesReference":5})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Check if object exists
            if (!varObj) {
                // Return empty list
                var variables = new Array();
                response.body = { variables: variables };
                this.sendResponse(response);
                // end the serialized call:
                this.serializer.endExec();
                return;
            }
            // Get contents
            varObj.getContent((varList) => {
                response.body = { variables: varList };
                this.sendResponse(response);
                // end the serialized call:
                this.serializer.endExec();
            }, args.start, args.count);
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=2, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=3, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=4, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=5, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=6, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=7, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=8, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=9, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=10, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=11, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=12, name=undefined), () => {
                handler(registers);
                innerSerializer.endExec();
            }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: stepIn({"threadId":1})
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 2
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=11, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=10, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=9, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=8, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=7, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=6, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=5, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=4, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=3, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=2, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
EmulDebugAdapter.sendResponse:  <-: variables({"variables":[{"name":"PC","type":"602Fh, 24623u, inc_fill_colors_ptr+4","value":"602Fh, 24623u, inc_fill_colors_ptr+4","variablesReference":0},{"name":"SP","type":"609Bh, 24731u, stack_bottom+18","value":"609Bh, 24731u, stack_bottom+18","variablesReference":0},{"name":"A","type":"10h, 16u, 16i, '.', 00010000","value":"10h, 16u, 16i, '.', 00010000","variablesReference":0},{"name":"F","type":"N","value":"N","variablesReference":0},{"name":"HL","type":"(6043h)b=48, 24643u, 24643i, fill_colors+1","value":"(6043h)b=48, 24643u, 24643i, fill_colors+1","variablesReference":0},{"name":"DE","type":"5AA0h, 23200u, 23200i, COLOR_SCREEN+672","value":"5AA0h, 23200u, 23200i, COLOR_SCREEN+672","variablesReference":0},{"name":"BC","type":"0000h, 0u, 0i","value":"0000h, 0u, 0i","variablesReference":0},{"name":"IX","type":"663Ch, 26172u, 26172i, stack_top+1439","value":"663Ch, 26172u, 26172i, stack_top+1439","variablesReference":0},{"name":"IY","type":"5C3Ah, 23610u, 23610i, COLOR_SCREEN+1082","value":"5C3Ah, 23610u, 23610i, COLOR_SCREEN+1082","variablesReference":0},{"name":"B","type":"00h, 0u, 0i, '0̲', 00000000","value":"00h, 0u, 0i, '0̲', 00000000","variablesReference":0},{"name":"C","type":"00h, 0u, 0i, '0̲', 00000000","value":"00h, 0u, 0i, '0̲', 00000000","variablesReference":0},{"name":"D","type":"5Ah, 90u, 90i, 'Z', 01011010","value":"5Ah, 90u, 90i, 'Z', 01011010","variablesReference":0},{"name":"E","type":"A0h, 160u, -96i, '.', 10100000","value":"A0h, 160u, -96i, '.', 10100000","variablesReference":0},{"name":"H","type":"60h, 96u, 96i, '`', 01100000","value":"60h, 96u, 96i, '`', 01100000","variablesReference":0},{"name":"L","type":"43h, 67u, 67i, 'C', 01000011","value":"43h, 67u, 67i, 'C', 01000011","variablesReference":0}]})
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
            // Check if object exists
            if (!varObj) {
                // Return empty list
                var variables = new Array();
                response.body = { variables: variables };
                this.sendResponse(response);
                // end the serialized call:
                this.serializer.endExec();
                return;
            }
            // Get contents
            varObj.getContent((varList) => {
                response.body = { variables: varList };
                this.sendResponse(response);
                // end the serialized call:
                this.serializer.endExec();
            }, args.start, args.count);
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                handler(registers);
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
EmulDebugAdapter.dispatchRequest:  ->: stepIn({"threadId":1})
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 2
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stepIn(undefined)
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendEvent:  <-: stopped({"reason":"step","threadId":1})
CallSerializer.exec:  Pushed (size=48, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=49, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=50, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=51, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=52, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=53, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
EmulDebugAdapter.dispatchRequest:  ->: threads(undefined)
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 2
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stepIn(undefined)
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: threads({"threads":[{"id":1,"name":"thread_default"}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
EmulDebugAdapter.sendEvent:  <-: stopped({"reason":"step","threadId":1})
CallSerializer.exec:  Pushed (size=54, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=55, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=56, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=57, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=58, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=59, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
CallSerializer.endExec:  Popped (size=58, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 2
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=3, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 3
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
EmulDebugAdapter.dispatchRequest:  ->: threads(undefined)
CallSerializer.exec:  Pushed (size=4, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 4
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CommandEntry.emulator_1.EmulatorClass.stackTraceRequest.handler.getRegisters.zesaruxSocket_1.zSocket.send.data:  Call stack: 6087H 
CallSerializer.endExec:  Popped (size=57, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=3, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 3
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=56, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=55, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=54, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
CallSerializer.endExec:  Popped (size=53, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=52, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=51, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=50, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=2, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":42,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":114,"column":0,"name":"CALL inc_fill_colors_ptr"}],"totalFrames":1})
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":42,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":114,"column":0,"name":"CALL inc_fill_colors_ptr"}],"totalFrames":1})
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: threads({"threads":[{"id":1,"name":"thread_default"}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=49, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=48, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 2
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=3, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 3
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
EmulDebugAdapter.dispatchRequest:  ->: scopes({"frameId":1})
CallSerializer.exec:  Pushed (size=4, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 4
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CommandEntry.emulator_1.EmulatorClass.stackTraceRequest.handler.getRegisters.zesaruxSocket_1.zSocket.send.data:  Call stack: 6087H 
CallSerializer.endExec:  Popped (size=47, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=3, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=2, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":42,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":114,"column":0,"name":"CALL inc_fill_colors_ptr"}],"totalFrames":1})
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":42,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":114,"column":0,"name":"CALL inc_fill_colors_ptr"}],"totalFrames":1})
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
EmulDebugAdapter.sendResponse:  <-: scopes({"scopes":[{"name":"Registers","variablesReference":1,"expensive":false},{"name":"Registers 2","variablesReference":2,"expensive":false},{"name":"Disassembly","variablesReference":3,"expensive":false},{"name":"Stack","variablesReference":4,"expensive":false}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=46, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=45, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.dispatchRequest:  ->: scopes({"frameId":1})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
EmulDebugAdapter.sendResponse:  <-: scopes({"scopes":[{"name":"Registers","variablesReference":5,"expensive":false},{"name":"Registers 2","variablesReference":6,"expensive":false},{"name":"Disassembly","variablesReference":7,"expensive":false},{"name":"Stack","variablesReference":8,"expensive":false}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=44, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.dispatchRequest:  ->: stepIn({"threadId":1})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stepIn(undefined)
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
EmulDebugAdapter.sendEvent:  <-: stopped({"reason":"step","threadId":1})
CallSerializer.exec:  Pushed (size=45, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=46, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=47, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=48, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=49, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=50, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
CallSerializer.endExec:  Popped (size=49, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=48, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
CallSerializer.endExec:  Popped (size=47, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.dispatchRequest:  ->: threads(undefined)
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: threads({"threads":[{"id":1,"name":"thread_default"}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=46, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 2
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=3, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 3
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
CommandEntry.emulator_1.EmulatorClass.stackTraceRequest.handler.getRegisters.zesaruxSocket_1.zSocket.send.data:  Call stack: 6087H 
CallSerializer.endExec:  Popped (size=45, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=2, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":43,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":114,"column":0,"name":"CALL inc_fill_colors_ptr"}],"totalFrames":1})
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":43,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":114,"column":0,"name":"CALL inc_fill_colors_ptr"}],"totalFrames":1})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=44, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=43, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=42, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
EmulDebugAdapter.dispatchRequest:  ->: scopes({"frameId":1})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
EmulDebugAdapter.sendResponse:  <-: scopes({"scopes":[{"name":"Registers","variablesReference":1,"expensive":false},{"name":"Registers 2","variablesReference":2,"expensive":false},{"name":"Disassembly","variablesReference":3,"expensive":false},{"name":"Stack","variablesReference":4,"expensive":false}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=41, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.dispatchRequest:  ->: stepIn({"threadId":1})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: variables({"variablesReference":1})
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
            // Check if object exists
            if (!varObj) {
                // Return empty list
                var variables = new Array();
                response.body = { variables: variables };
                this.sendResponse(response);
                // end the serialized call:
                this.serializer.endExec();
                return;
            }
            // Get contents
            varObj.getContent((varList) => {
                response.body = { variables: varList };
                this.sendResponse(response);
                // end the serialized call:
                this.serializer.endExec();
            }, args.start, args.count);
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 2
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stepIn(undefined)
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
            // Step-Into
            emulatorfactory_1.Emulator.stepInto((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepInto: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendEvent:  <-: stopped({"reason":"step","threadId":1})
CallSerializer.exec:  Pushed (size=42, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=43, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=44, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=45, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=46, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=47, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=2, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=3, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=4, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=5, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=6, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=7, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=8, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=9, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=10, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=11, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=12, name=undefined), () => {
                handler(registers);
                innerSerializer.endExec();
            }
EmulDebugAdapter.dispatchRequest:  ->: threads(undefined)
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 2
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=11, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=10, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=9, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=8, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=7, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=6, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=5, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=4, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=3, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=2, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
EmulDebugAdapter.sendResponse:  <-: variables({"variables":[{"name":"PC","type":"6038h, 24632u, inc_fill_colors_ptr+13","value":"6038h, 24632u, inc_fill_colors_ptr+13","variablesReference":0},{"name":"SP","type":"609Bh, 24731u, stack_bottom+18","value":"609Bh, 24731u, stack_bottom+18","variablesReference":0},{"name":"A","type":"10h, 16u, 16i, '.', 00010000","value":"10h, 16u, 16i, '.', 00010000","variablesReference":0},{"name":"F","type":"SHNC","value":"SHNC","variablesReference":0},{"name":"HL","type":"(FFFCh)b=0, 65532u, -4i, stack_top+40799","value":"(FFFCh)b=0, 65532u, -4i, stack_top+40799","variablesReference":0},{"name":"DE","type":"5AA0h, 23200u, 23200i, COLOR_SCREEN+672","value":"5AA0h, 23200u, 23200i, COLOR_SCREEN+672","variablesReference":0},{"name":"BC","type":"6047h, 24647u, 24647i, fill_colors_end","value":"6047h, 24647u, 24647i, fill_colors_end","variablesReference":0},{"name":"IX","type":"663Ch, 26172u, 26172i, stack_top+1439","value":"663Ch, 26172u, 26172i, stack_top+1439","variablesReference":0},{"name":"IY","type":"5C3Ah, 23610u, 23610i, COLOR_SCREEN+1082","value":"5C3Ah, 23610u, 23610i, COLOR_SCREEN+1082","variablesReference":0},{"name":"B","type":"60h, 96u, 96i, '`', 01100000","value":"60h, 96u, 96i, '`', 01100000","variablesReference":0},{"name":"C","type":"47h, 71u, 71i, 'G', 01000111","value":"47h, 71u, 71i, 'G', 01000111","variablesReference":0},{"name":"D","type":"5Ah, 90u, 90i, 'Z', 01011010","value":"5Ah, 90u, 90i, 'Z', 01011010","variablesReference":0},{"name":"E","type":"A0h, 160u, -96i, '.', 10100000","value":"A0h, 160u, -96i, '.', 10100000","variablesReference":0},{"name":"H","type":"FFh, 255u, -1i, '.', 11111111","value":"FFh, 255u, -1i, '.', 11111111","variablesReference":0},{"name":"L","type":"FCh, 252u, -4i, '.', 11111100","value":"FCh, 252u, -4i, '.', 11111100","variablesReference":0}]})
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
            // Check if object exists
            if (!varObj) {
                // Return empty list
                var variables = new Array();
                response.body = { variables: variables };
                this.sendResponse(response);
                // end the serialized call:
                this.serializer.endExec();
                return;
            }
            // Get contents
            varObj.getContent((varList) => {
                response.body = { variables: varList };
                this.sendResponse(response);
                // end the serialized call:
                this.serializer.endExec();
            }, args.start, args.count);
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: threads({"threads":[{"id":1,"name":"thread_default"}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                handler(registers);
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=46, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=45, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 2
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=3, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 3
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
CommandEntry.emulator_1.EmulatorClass.stackTraceRequest.handler.getRegisters.zesaruxSocket_1.zSocket.send.data:  Call stack: 6087H 
CallSerializer.endExec:  Popped (size=44, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=2, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":44,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":114,"column":0,"name":"CALL inc_fill_colors_ptr"}],"totalFrames":1})
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":44,"column":0,"name":"PC"},{"id":2,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":114,"column":0,"name":"CALL inc_fill_colors_ptr"}],"totalFrames":1})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=43, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=42, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
CallSerializer.endExec:  Popped (size=41, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.dispatchRequest:  ->: scopes({"frameId":1})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
EmulDebugAdapter.sendResponse:  <-: scopes({"scopes":[{"name":"Registers","variablesReference":1,"expensive":false},{"name":"Registers 2","variablesReference":2,"expensive":false},{"name":"Disassembly","variablesReference":3,"expensive":false},{"name":"Stack","variablesReference":4,"expensive":false}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=40, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.dispatchRequest:  ->: variables({"variablesReference":1})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Check if object exists
            if (!varObj) {
                // Return empty list
                var variables = new Array();
                response.body = { variables: variables };
                this.sendResponse(response);
                // end the serialized call:
                this.serializer.endExec();
                return;
            }
            // Get contents
            varObj.getContent((varList) => {
                response.body = { variables: varList };
                this.sendResponse(response);
                // end the serialized call:
                this.serializer.endExec();
            }, args.start, args.count);
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=2, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=3, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=4, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=5, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=6, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=7, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=8, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=9, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=10, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=11, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=12, name=undefined), () => {
                handler(registers);
                innerSerializer.endExec();
            }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=11, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=10, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=9, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=8, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=7, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=6, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=5, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=4, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=3, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=2, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
EmulDebugAdapter.sendResponse:  <-: variables({"variables":[{"name":"PC","type":"6038h, 24632u, inc_fill_colors_ptr+13","value":"6038h, 24632u, inc_fill_colors_ptr+13","variablesReference":0},{"name":"SP","type":"609Bh, 24731u, stack_bottom+18","value":"609Bh, 24731u, stack_bottom+18","variablesReference":0},{"name":"A","type":"10h, 16u, 16i, '.', 00010000","value":"10h, 16u, 16i, '.', 00010000","variablesReference":0},{"name":"F","type":"SHNC","value":"SHNC","variablesReference":0},{"name":"HL","type":"(FFFCh)b=0, 65532u, -4i, stack_top+40799","value":"(FFFCh)b=0, 65532u, -4i, stack_top+40799","variablesReference":0},{"name":"DE","type":"5AA0h, 23200u, 23200i, COLOR_SCREEN+672","value":"5AA0h, 23200u, 23200i, COLOR_SCREEN+672","variablesReference":0},{"name":"BC","type":"6047h, 24647u, 24647i, fill_colors_end","value":"6047h, 24647u, 24647i, fill_colors_end","variablesReference":0},{"name":"IX","type":"663Ch, 26172u, 26172i, stack_top+1439","value":"663Ch, 26172u, 26172i, stack_top+1439","variablesReference":0},{"name":"IY","type":"5C3Ah, 23610u, 23610i, COLOR_SCREEN+1082","value":"5C3Ah, 23610u, 23610i, COLOR_SCREEN+1082","variablesReference":0},{"name":"B","type":"60h, 96u, 96i, '`', 01100000","value":"60h, 96u, 96i, '`', 01100000","variablesReference":0},{"name":"C","type":"47h, 71u, 71i, 'G', 01000111","value":"47h, 71u, 71i, 'G', 01000111","variablesReference":0},{"name":"D","type":"5Ah, 90u, 90i, 'Z', 01011010","value":"5Ah, 90u, 90i, 'Z', 01011010","variablesReference":0},{"name":"E","type":"A0h, 160u, -96i, '.', 10100000","value":"A0h, 160u, -96i, '.', 10100000","variablesReference":0},{"name":"H","type":"FFh, 255u, -1i, '.', 11111111","value":"FFh, 255u, -1i, '.', 11111111","variablesReference":0},{"name":"L","type":"FCh, 252u, -4i, '.', 11111100","value":"FCh, 252u, -4i, '.', 11111100","variablesReference":0}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Check if object exists
            if (!varObj) {
                // Return empty list
                var variables = new Array();
                response.body = { variables: variables };
                this.sendResponse(response);
                // end the serialized call:
                this.serializer.endExec();
                return;
            }
            // Get contents
            varObj.getContent((varList) => {
                response.body = { variables: varList };
                this.sendResponse(response);
                // end the serialized call:
                this.serializer.endExec();
            }, args.start, args.count);
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                handler(registers);
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=39, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=38, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=37, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=36, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
CallSerializer.endExec:  Popped (size=35, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=34, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=33, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=32, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=31, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=30, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
CallSerializer.endExec:  Popped (size=29, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=28, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=27, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=26, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=25, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=24, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
CallSerializer.endExec:  Popped (size=23, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=22, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=21, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=20, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=19, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=18, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
CallSerializer.endExec:  Popped (size=17, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=16, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=15, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=14, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=13, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=12, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
CallSerializer.endExec:  Popped (size=11, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=10, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=9, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=8, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=7, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=6, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
CallSerializer.endExec:  Popped (size=5, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=4, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=3, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=2, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
...
Pause for 3.087 secs.
...
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
EmulDebugAdapter.dispatchRequest:  ->: next({"threadId":1})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Step-Over
            emulatorfactory_1.Emulator.stepOver((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepOver: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: next(undefined)
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Step-Over
            emulatorfactory_1.Emulator.stepOver((disasm, tStates, cpuFreq) => {
                // Display T-states and time
                const text = disasm ? disasm + ' \t; ' : '';
                this.showUsedTStates('StepOver: ' + text, tStates, cpuFreq);
                // Update memory dump etc.
                this.update({ step: true });
                // Response
                this.sendResponse(response);
                this.serializer.endExec();
                // Send event
                this.sendEvent(new main_1.StoppedEvent('step', EmulDebugAdapter.THREAD_ID));
            });
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
EmulDebugAdapter.sendEvent:  <-: stopped({"reason":"step","threadId":1})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=3, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=4, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=5, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.exec:  Pushed (size=6, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
CallSerializer.endExec:  Popped (size=5, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.dispatchRequest:  ->: threads(undefined)
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: threads({"threads":[{"id":1,"name":"thread_default"}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Just return a default thread.
            response.body = {
                threads: [
                    new main_1.Thread(EmulDebugAdapter.THREAD_ID, "thread_default")
                ]
            };
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=4, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 2
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=3, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 3
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined } { func: [Function], name: undefined }
EmulDebugAdapter.dispatchRequest:  ->: stackTrace({"threadId":1,"startFrame":0,"levels":20})
CallSerializer.endExec:  Popped (size=3, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=2, name=undefined), () => {
            // Clear all variables
            this.listVariables.length = 0;
            // Get the call stack trace.
            emulatorfactory_1.Emulator.stackTraceRequest(frames => {
                // Check frames for end
                const frameRealCount = frames.length;
                for (; frameCount < frameRealCount; frameCount++) {
                    const frame = frames[frameCount];
                    // Check if end
                    if (frame.name === null) {
                        // rest of stack trace is garbage
                        break;
                    }
                }
                // Go through complete call stack and get the sources.
                // If no source exists than get a hexdump and disassembly later.
                for (let index = 0; index < frameCount; index++) {
                    const frame = frames[index];
                    // Get file for address
                    const addr = frame.addr;
                    const file = labels_1.Labels.getFileAndLineForAddress(addr);
                    // Store file, if it does not exist the name is empty
                    const src = this.createSource(file.fileName);
                    const lineNr = (src) ? this.convertDebuggerLineToClient(file.lineNr) : 0;
                    const sf = new main_1.StackFrame(index + 1, frame.name, src, lineNr);
                    sfrs.push(sf);
                }
                // Create array with addresses that need to be fetched for disassembly
                for (let index = 0; index < frameCount; index++) {
                    const sf = sfrs[index];
                    if (!sf.source)
                        fetchAddresses.push(frames[index].addr);
                }
                // Check if we need to fetch any dump.
                const fetchAddressesCount = fetchAddresses.length;
                if (fetchAddressesCount == 0) {
                    // No dumps to fetch
                    this.serializer.endExec();
                    return;
                }
                // Now get hexdumps for all non existing sources.
                let fetchCount = 0;
                for (let index = 0; index < fetchAddressesCount; index++) {
                    // So fetch a memory dump
                    const fetchAddress = fetchAddresses[index];
                    const fetchSize = 100; // N bytes
                    emulatorfactory_1.Emulator.getMemoryDump(fetchAddress, fetchSize, data => {
                        // Save data for later writing
                        fetchData.push(data);
                        // Note: because of self-modifying code it may have changed
                        // since it was fetched at the beginning.
                        // Check if memory changed.
                        if (!doDisassembly) {
                            const checkSize = 40; // Needs to be smaller than fetchsize in order not to do a disassembly too often.
                            for (let k = 0; k < checkSize; k++) {
                                const val = this.dasm.memory.getValueAt(fetchAddress + k);
                                const memAttr = this.dasm.memory.getAttributeAt(fetchAddress + k);
                                if ((val != data[k]) || (memAttr == memory_1.MemAttribute.UNUSED)) {
                                    doDisassembly = true;
                                    break;
                                }
                            }
                        }
                        // Check for end
                        fetchCount++;
                        if (fetchCount >= fetchAddressesCount) {
                            // All dumps fetched
                            this.serializer.endExec();
                        }
                    });
                }
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined } { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
            // Check if a new address was used.
            const fetchAddressesCount = fetchAddresses.length;
            for (let i = 0; i < fetchAddressesCount; i++) {
                // The current PC is for sure a code label.
                const addr = fetchAddresses[i];
                if (this.dasmAddressQueue.indexOf(addr) < 0)
                    this.dasmAddressQueue.unshift(addr);
                // Check if this requires a  disassembly
                if (!doDisassembly) {
                    const memAttr = this.dasm.memory.getAttributeAt(addr);
                    if (!(memAttr & memory_1.MemAttribute.CODE_FIRST))
                        doDisassembly = true; // If memory was not the start of an opcode.
                }
            }
            // Check if disassembly is required.
            if (!doDisassembly) {
                // End
                this.serializer.endExec();
                return;
            }
            this.serializer.setProgress("Do disassembly");
            // Do disassembly.
            // Write new fetched memory
            const count = fetchAddresses.length;
            for (let i = 0; i < count; i++) {
                this.dasm.setMemory(fetchAddresses[i], fetchData[i]);
            }
            this.dasm.setAddressQueue(this.dasmAddressQueue);
            // Disassemble
            this.dasm.memory.clrAssignedAttributesAt(0x0000, 0x10000); // Clear all memory attributes before next disassembly.
            this.dasm.initLabels(); // Clear all labels.
            this.dasm.disassemble();
            // Read data
            const text = this.dasm.getDisassemblyText();
            // Get all source breakpoints of the disassembly file.
            const bps = vscode.debug.breakpoints;
            const disSrc = this.disasmTextDoc.uri.toString();
            const sbps = bps.filter(bp => {
                if (bp.hasOwnProperty('location')) {
                    const sbp = bp;
                    const sbpSrc = sbp.location.uri.toString();
                    if (sbpSrc == disSrc)
                        return true;
                }
                return false;
            });
            this.serializer.setProgress("Check if any breakpoint");
            // Check if any breakpoint
            const changedBps = new Array();
            if (sbps.length > 0) {
                // Previous text
                const prevTextLines = this.disasmTextDoc.getText().split('\n');
                // Loop all source breakpoints to compute changed BPs
                for (const sbp of sbps) {
                    const lineNr = sbp.location.range.start.line;
                    const line = prevTextLines[lineNr];
                    const addr = parseInt(line, 16);
                    if (!isNaN(addr)) {
                        // Get new line
                        const lines = this.dasm.getDisassemblyLines();
                        const nLineNr = this.searchLines(lines, addr);
                        // Create breakpoint
                        const nLoc = new vscode.Location(this.disasmTextDoc.uri, new vscode.Position(nLineNr, 0));
                        const cbp = new vscode.SourceBreakpoint(nLoc, sbp.enabled, sbp.condition, sbp.hitCondition, sbp.logMessage);
                        // Store
                        changedBps.push(cbp);
                    }
                }
            }
            this.serializer.setProgress("Remove all old breakpoints");
            // Remove all old breakpoints.
            vscode.debug.removeBreakpoints(sbps);
            // Create and apply one replace edit
            const editReplace = new vscode.WorkspaceEdit();
            editReplace.replace(this.disasmTextDoc.uri, new vscode.Range(0, 0, this.disasmTextDoc.lineCount, 0), text);
            this.serializer.setProgress("applyEdit");
            vscode.workspace.applyEdit(editReplace).then(() => {
                // Save after edit (to be able to set breakpoints)
                this.serializer.setProgress("disasmTextDoc.save");
                this.disasmTextDoc.save().then(() => {
                    this.serializer.setProgress("debug.addBreakpoints");
                    // Add all new breakpoints.
                    vscode.debug.addBreakpoints(changedBps);
                    // End
                    this.serializer.endExec();
                });
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":115,"column":0,"name":"PC"}],"totalFrames":1})
EmulDebugAdapter.sendResponse:  <-: stackTrace({"stackFrames":[{"id":1,"source":{"name":"disasm.asm","path":"C:\\Users\\rob\\Documents\\1-github\\z80-sample-program\\.tmp\\disasm.asm","sourceReference":0},"line":115,"column":0,"name":"PC"}],"totalFrames":1})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Determine line numbers (binary search)
            if (frameCount > 0) {
                const relFilePath = utility_1.Utility.getRelTmpDisasmFilePath();
                const absFilePath = utility_1.Utility.getAbsFilePath(relFilePath);
                const src = this.createSource(absFilePath);
                const lines = this.dasm.getDisassemblyLines();
                let indexDump = 0;
                for (let i = 0; i < frameCount; i++) {
                    const sf = sfrs[i];
                    if (sf.source)
                        continue;
                    // Get line number for stack address
                    const addr = fetchAddresses[indexDump];
                    const foundLine = this.searchLines(lines, addr);
                    const lineNr = this.convertDebuggerLineToClient(foundLine);
                    // Store
                    sf.source = src;
                    sf.line = lineNr;
                    // Next
                    indexDump++;
                }
            }
            // Send as often as there have been requests
            while (this.stackTraceResponses.length > 0) {
                const resp = this.stackTraceResponses[0];
                this.stackTraceResponses.shift();
                resp.body = { stackFrames: sfrs, totalFrames: 1 };
                this.sendResponse(resp);
            }
            // end the serialized call:
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=2, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
EmulDebugAdapter.dispatchRequest:  ->: scopes({"frameId":1})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
EmulDebugAdapter.sendResponse:  <-: scopes({"scopes":[{"name":"Registers","variablesReference":1,"expensive":false},{"name":"Registers 2","variablesReference":2,"expensive":false},{"name":"Disassembly","variablesReference":3,"expensive":false},{"name":"Stack","variablesReference":4,"expensive":false}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            const scopes = new Array();
            const frameId = args.frameId;
            //const frame = this.listFrames.getObject(frameId);
            const frame = emulatorfactory_1.Emulator.getFrame(frameId);
            if (!frame) {
                // No frame found, send empty response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                this.serializer.endExec();
                return;
            }
            // More serialization
            const innerSerializer = new callserializer_1.CallSerializer("innerScopesRequest");
            // Serialize main Registers
            innerSerializer.exec(() => {
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for Registers
                const varRegistersMain = new shallowvar_1.RegistersMainVar();
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varRegistersMain);
                scopes.push(new main_1.Scope("Registers", ref));
                // TODO: later (with change in zesarux) I need to include the frame ID/callstack address as well
                // Create variable object for secondary Registers
                const varRegisters2 = new shallowvar_1.RegistersSecondaryVar();
                // Add to list and get reference ID
                const ref2 = this.listVariables.addObject(varRegisters2);
                scopes.push(new main_1.Scope("Registers 2", ref2));
                // Return
                innerSerializer.endExec();
            });
            // Serialize Disassembly
            innerSerializer.exec(() => {
                // get address
                if (frame) {
                    // use address
                    const addr = frame.addr;
                    // Create variable object for Disassembly
                    const varDisassembly = new shallowvar_1.DisassemblyVar(addr, 8);
                    // Add to list and get reference ID
                    const ref = this.listVariables.addObject(varDisassembly);
                    scopes.push(new main_1.Scope("Disassembly", ref));
                }
                // Return
                innerSerializer.endExec();
            });
            // Serialize the Stack
            innerSerializer.exec(() => {
                // Create variable object for the stack
                const varStack = new shallowvar_1.StackVar(frame.stack, frame.stackStartAddress);
                // Add to list and get reference ID
                const ref = this.listVariables.addObject(varStack);
                scopes.push(new main_1.Scope("Stack", ref));
                // Send response
                response.body = { scopes: scopes };
                this.sendResponse(response);
                // Return
                innerSerializer.endExec();
                this.serializer.endExec();
            });
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
                // Updates the shown memory dump.
                emulatorfactory_1.Emulator.getMemoryDump(metaBlock.address, metaBlock.size, (data) => {
                    // Store data
                    metaBlock.prevData = metaBlock.data;
                    metaBlock.data = data;
                    // end
                    this.serializer.endExec();
                });
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Now combine all data and create the html.
            this.setHtml();
            // end
            this.serializer.endExec();
        }
EmulDebugAdapter.dispatchRequest:  ->: evaluate({"expression":"L6075","frameId":1,"context":"hover"})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            log_1.Log.log('evaluate.expression: ' + args.expression);
            log_1.Log.log('evaluate.context: ' + args.context);
            log_1.Log.log('evaluate.format: ' + args.format);
            // get the name
            const name = expression;
            // Check if it is a register
            if (z80Registers_1.Z80Registers.isRegister(name)) {
                const formatMap = (args.context == 'hover') ? z80Registers_1.Z80RegisterHoverFormat : z80Registers_1.Z80RegisterVarFormat;
                utility_1.Utility.getFormattedRegister(name, formatMap, (formattedValue) => {
                    response.body = {
                        result: formattedValue,
                        variablesReference: 0
                    };
                    this.sendResponse(response);
                    this.serializer.endExec();
                });
                return;
            }
            // Check if it is a label. A label may have a special formatting:
            // Example: LBL_TEXT 10, b
            // = Addresse LBL_TEXT, 10 bytes
            const match = /^@?([^\s,]+)\s*(,\s*([^\s,]*))?(,\s*([^\s,]*))?/.exec(name);
            if (match) {
                let labelString = match[1];
                let sizeString = match[3];
                let byteWord = match[5];
                // Defaults
                if (labelString) {
                    let labelValue = NaN;
                    let lastLabel;
                    let modulePrefix;
                    // First check for module name and local label prefix (sjasmplus).
                    if (emulatorfactory_1.Emulator.RegisterCache) {
                        // Get current pc
                        const pc = z80Registers_1.Z80Registers.parsePC(emulatorfactory_1.Emulator.RegisterCache);
                        const entry = labels_1.Labels.getFileAndLineForAddress(pc);
                        // Local label and prefix
                        lastLabel = entry.lastLabel;
                        modulePrefix = entry.modulePrefix;
                    }
                    // Convert label
                    try {
                        labelValue = utility_1.Utility.evalExpression(labelString, false, modulePrefix, lastLabel);
                    }
                    catch (_a) { }
                    if (!isNaN(labelValue)) {
                        var size = 100;
                        if (sizeString) {
                            const readSize = labels_1.Labels.getNumberFromString(sizeString) || NaN;
                            if (!isNaN(readSize))
                                size = readSize;
                        }
                        if (!byteWord || byteWord.length == 0)
                            byteWord = "bw"; // both byte and word
                        // Now create a "variable" for the bigValues or small values
                        const format = (labelValue <= settings_1.Settings.launch.smallValuesMaximum) ? settings_1.Settings.launch.formatting.smallValues : settings_1.Settings.launch.formatting.bigValues;
                        utility_1.Utility.numberFormatted(name, labelValue, 2, format, undefined, (formattedValue) => {
                            if (labelValue <= settings_1.Settings.launch.smallValuesMaximum) {
                                // small value
                                // Response
                                response.body = {
                                    result: (args.context == 'hover') ? name + ': ' + formattedValue : formattedValue,
                                    variablesReference: 0,
                                };
                            }
                            else {
                                // big value
                                // Create a label variable
                                const labelVar = new shallowvar_1.LabelVar(labelValue, size, byteWord, this.listVariables);
                                // Add to list
                                const ref = this.listVariables.addObject(labelVar);
                                // Response
                                response.body = {
                                    result: (args.context == 'hover') ? name + ': ' + formattedValue : formattedValue,
                                    variablesReference: ref,
                                    type: "data",
                                    //presentationHint: ,
                                    namedVariables: 2,
                                };
                            }
                            ;
                            this.sendResponse(response);
                            this.serializer.endExec();
                        });
                        return;
                    }
                }
            }
            // Default: return nothing
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
main_1.DebugSession.evaluateRequest.args.serializer.exec:  evaluate.expression: L6075
main_1.DebugSession.evaluateRequest.args.serializer.exec:  evaluate.context: hover
main_1.DebugSession.evaluateRequest.args.serializer.exec:  evaluate.format: undefined
EmulDebugAdapter.sendResponse:  <-: evaluate(undefined)
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            log_1.Log.log('evaluate.expression: ' + args.expression);
            log_1.Log.log('evaluate.context: ' + args.context);
            log_1.Log.log('evaluate.format: ' + args.format);
            // get the name
            const name = expression;
            // Check if it is a register
            if (z80Registers_1.Z80Registers.isRegister(name)) {
                const formatMap = (args.context == 'hover') ? z80Registers_1.Z80RegisterHoverFormat : z80Registers_1.Z80RegisterVarFormat;
                utility_1.Utility.getFormattedRegister(name, formatMap, (formattedValue) => {
                    response.body = {
                        result: formattedValue,
                        variablesReference: 0
                    };
                    this.sendResponse(response);
                    this.serializer.endExec();
                });
                return;
            }
            // Check if it is a label. A label may have a special formatting:
            // Example: LBL_TEXT 10, b
            // = Addresse LBL_TEXT, 10 bytes
            const match = /^@?([^\s,]+)\s*(,\s*([^\s,]*))?(,\s*([^\s,]*))?/.exec(name);
            if (match) {
                let labelString = match[1];
                let sizeString = match[3];
                let byteWord = match[5];
                // Defaults
                if (labelString) {
                    let labelValue = NaN;
                    let lastLabel;
                    let modulePrefix;
                    // First check for module name and local label prefix (sjasmplus).
                    if (emulatorfactory_1.Emulator.RegisterCache) {
                        // Get current pc
                        const pc = z80Registers_1.Z80Registers.parsePC(emulatorfactory_1.Emulator.RegisterCache);
                        const entry = labels_1.Labels.getFileAndLineForAddress(pc);
                        // Local label and prefix
                        lastLabel = entry.lastLabel;
                        modulePrefix = entry.modulePrefix;
                    }
                    // Convert label
                    try {
                        labelValue = utility_1.Utility.evalExpression(labelString, false, modulePrefix, lastLabel);
                    }
                    catch (_a) { }
                    if (!isNaN(labelValue)) {
                        var size = 100;
                        if (sizeString) {
                            const readSize = labels_1.Labels.getNumberFromString(sizeString) || NaN;
                            if (!isNaN(readSize))
                                size = readSize;
                        }
                        if (!byteWord || byteWord.length == 0)
                            byteWord = "bw"; // both byte and word
                        // Now create a "variable" for the bigValues or small values
                        const format = (labelValue <= settings_1.Settings.launch.smallValuesMaximum) ? settings_1.Settings.launch.formatting.smallValues : settings_1.Settings.launch.formatting.bigValues;
                        utility_1.Utility.numberFormatted(name, labelValue, 2, format, undefined, (formattedValue) => {
                            if (labelValue <= settings_1.Settings.launch.smallValuesMaximum) {
                                // small value
                                // Response
                                response.body = {
                                    result: (args.context == 'hover') ? name + ': ' + formattedValue : formattedValue,
                                    variablesReference: 0,
                                };
                            }
                            else {
                                // big value
                                // Create a label variable
                                const labelVar = new shallowvar_1.LabelVar(labelValue, size, byteWord, this.listVariables);
                                // Add to list
                                const ref = this.listVariables.addObject(labelVar);
                                // Response
                                response.body = {
                                    result: (args.context == 'hover') ? name + ': ' + formattedValue : formattedValue,
                                    variablesReference: ref,
                                    type: "data",
                                    //presentationHint: ,
                                    namedVariables: 2,
                                };
                            }
                            ;
                            this.sendResponse(response);
                            this.serializer.endExec();
                        });
                        return;
                    }
                }
            }
            // Default: return nothing
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
EmulDebugAdapter.dispatchRequest:  ->: variables({"variablesReference":1})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            // Check if object exists
            if (!varObj) {
                // Return empty list
                var variables = new Array();
                response.body = { variables: variables };
                this.sendResponse(response);
                // end the serialized call:
                this.serializer.endExec();
                return;
            }
            // Get contents
            varObj.getContent((varList) => {
                response.body = { variables: varList };
                this.sendResponse(response);
                // end the serialized call:
                this.serializer.endExec();
            }, args.start, args.count);
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=2, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=2, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=3, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=4, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=5, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=6, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=7, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=8, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=9, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=10, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=11, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=12, name=undefined), () => {
                handler(registers);
                innerSerializer.endExec();
            }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 1
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
CallSerializer.endExec:  Popped (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=11, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=10, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=9, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=8, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=7, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=6, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=5, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=4, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=3, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=2, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=1, name=undefined), () => {
                    z80Registers_1.Z80Registers.getVarFormattedReg(regName, data, (formattedValue) => {
                        registers.push({
                            name: regName,
                            type: formattedValue,
                            value: formattedValue,
                            variablesReference: 0
                        });
                        innerSerializer.endExec();
                    });
                }
EmulDebugAdapter.sendResponse:  <-: variables({"variables":[{"name":"PC","type":"6087h, 24711u, main_loop+18","value":"6087h, 24711u, main_loop+18","variablesReference":0},{"name":"SP","type":"609Dh, 24733u, stack_top","value":"609Dh, 24733u, stack_top","variablesReference":0},{"name":"A","type":"10h, 16u, 16i, '.', 00010000","value":"10h, 16u, 16i, '.', 00010000","variablesReference":0},{"name":"F","type":"SHNC","value":"SHNC","variablesReference":0},{"name":"HL","type":"(FFFCh)b=0, 65532u, -4i, stack_top+40799","value":"(FFFCh)b=0, 65532u, -4i, stack_top+40799","variablesReference":0},{"name":"DE","type":"5AA0h, 23200u, 23200i, COLOR_SCREEN+672","value":"5AA0h, 23200u, 23200i, COLOR_SCREEN+672","variablesReference":0},{"name":"BC","type":"6047h, 24647u, 24647i, fill_colors_end","value":"6047h, 24647u, 24647i, fill_colors_end","variablesReference":0},{"name":"IX","type":"663Ch, 26172u, 26172i, stack_top+1439","value":"663Ch, 26172u, 26172i, stack_top+1439","variablesReference":0},{"name":"IY","type":"5C3Ah, 23610u, 23610i, COLOR_SCREEN+1082","value":"5C3Ah, 23610u, 23610i, COLOR_SCREEN+1082","variablesReference":0},{"name":"B","type":"60h, 96u, 96i, '`', 01100000","value":"60h, 96u, 96i, '`', 01100000","variablesReference":0},{"name":"C","type":"47h, 71u, 71i, 'G', 01000111","value":"47h, 71u, 71i, 'G', 01000111","variablesReference":0},{"name":"D","type":"5Ah, 90u, 90i, 'Z', 01011010","value":"5Ah, 90u, 90i, 'Z', 01011010","variablesReference":0},{"name":"E","type":"A0h, 160u, -96i, '.', 10100000","value":"A0h, 160u, -96i, '.', 10100000","variablesReference":0},{"name":"H","type":"FFh, 255u, -1i, '.', 11111111","value":"FFh, 255u, -1i, '.', 11111111","variablesReference":0},{"name":"L","type":"FCh, 252u, -4i, '.', 11111100","value":"FCh, 252u, -4i, '.', 11111100","variablesReference":0}]})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            // Check if object exists
            if (!varObj) {
                // Return empty list
                var variables = new Array();
                response.body = { variables: variables };
                this.sendResponse(response);
                // end the serialized call:
                this.serializer.endExec();
                return;
            }
            // Get contents
            varObj.getContent((varList) => {
                response.body = { variables: varList };
                this.sendResponse(response);
                // end the serialized call:
                this.serializer.endExec();
            }, args.start, args.count);
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
                handler(registers);
                innerSerializer.endExec();
            }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
...
Pause for 47.334 secs.
...
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
EmulDebugAdapter.dispatchRequest:  ->: evaluate({"expression":"34","frameId":1,"context":"hover"})
CallSerializer.exec:  Pushed (size=1, name=undefined), () => {
            log_1.Log.log('evaluate.expression: ' + args.expression);
            log_1.Log.log('evaluate.context: ' + args.context);
            log_1.Log.log('evaluate.format: ' + args.format);
            // get the name
            const name = expression;
            // Check if it is a register
            if (z80Registers_1.Z80Registers.isRegister(name)) {
                const formatMap = (args.context == 'hover') ? z80Registers_1.Z80RegisterHoverFormat : z80Registers_1.Z80RegisterVarFormat;
                utility_1.Utility.getFormattedRegister(name, formatMap, (formattedValue) => {
                    response.body = {
                        result: formattedValue,
                        variablesReference: 0
                    };
                    this.sendResponse(response);
                    this.serializer.endExec();
                });
                return;
            }
            // Check if it is a label. A label may have a special formatting:
            // Example: LBL_TEXT 10, b
            // = Addresse LBL_TEXT, 10 bytes
            const match = /^@?([^\s,]+)\s*(,\s*([^\s,]*))?(,\s*([^\s,]*))?/.exec(name);
            if (match) {
                let labelString = match[1];
                let sizeString = match[3];
                let byteWord = match[5];
                // Defaults
                if (labelString) {
                    let labelValue = NaN;
                    let lastLabel;
                    let modulePrefix;
                    // First check for module name and local label prefix (sjasmplus).
                    if (emulatorfactory_1.Emulator.RegisterCache) {
                        // Get current pc
                        const pc = z80Registers_1.Z80Registers.parsePC(emulatorfactory_1.Emulator.RegisterCache);
                        const entry = labels_1.Labels.getFileAndLineForAddress(pc);
                        // Local label and prefix
                        lastLabel = entry.lastLabel;
                        modulePrefix = entry.modulePrefix;
                    }
                    // Convert label
                    try {
                        labelValue = utility_1.Utility.evalExpression(labelString, false, modulePrefix, lastLabel);
                    }
                    catch (_a) { }
                    if (!isNaN(labelValue)) {
                        var size = 100;
                        if (sizeString) {
                            const readSize = labels_1.Labels.getNumberFromString(sizeString) || NaN;
                            if (!isNaN(readSize))
                                size = readSize;
                        }
                        if (!byteWord || byteWord.length == 0)
                            byteWord = "bw"; // both byte and word
                        // Now create a "variable" for the bigValues or small values
                        const format = (labelValue <= settings_1.Settings.launch.smallValuesMaximum) ? settings_1.Settings.launch.formatting.smallValues : settings_1.Settings.launch.formatting.bigValues;
                        utility_1.Utility.numberFormatted(name, labelValue, 2, format, undefined, (formattedValue) => {
                            if (labelValue <= settings_1.Settings.launch.smallValuesMaximum) {
                                // small value
                                // Response
                                response.body = {
                                    result: (args.context == 'hover') ? name + ': ' + formattedValue : formattedValue,
                                    variablesReference: 0,
                                };
                            }
                            else {
                                // big value
                                // Create a label variable
                                const labelVar = new shallowvar_1.LabelVar(labelValue, size, byteWord, this.listVariables);
                                // Add to list
                                const ref = this.listVariables.addObject(labelVar);
                                // Response
                                response.body = {
                                    result: (args.context == 'hover') ? name + ': ' + formattedValue : formattedValue,
                                    variablesReference: ref,
                                    type: "data",
                                    //presentationHint: ,
                                    namedVariables: 2,
                                };
                            }
                            ;
                            this.sendResponse(response);
                            this.serializer.endExec();
                        });
                        return;
                    }
                }
            }
            // Default: return nothing
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  runQueueFunction undefined
CallSerializer.log:  Main.CallSerializer:  { func: [Function], name: undefined }
main_1.DebugSession.evaluateRequest.args.serializer.exec:  evaluate.expression: 34
main_1.DebugSession.evaluateRequest.args.serializer.exec:  evaluate.context: hover
main_1.DebugSession.evaluateRequest.args.serializer.exec:  evaluate.format: undefined
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
EmulDebugAdapter.sendResponse:  <-: evaluate({"result":"34: 0022h, 34u, 34i, '\"', 0000000000100010","variablesReference":0})
CallSerializer.endExec:  Popped (size=0, name=undefined), () => {
            log_1.Log.log('evaluate.expression: ' + args.expression);
            log_1.Log.log('evaluate.context: ' + args.context);
            log_1.Log.log('evaluate.format: ' + args.format);
            // get the name
            const name = expression;
            // Check if it is a register
            if (z80Registers_1.Z80Registers.isRegister(name)) {
                const formatMap = (args.context == 'hover') ? z80Registers_1.Z80RegisterHoverFormat : z80Registers_1.Z80RegisterVarFormat;
                utility_1.Utility.getFormattedRegister(name, formatMap, (formattedValue) => {
                    response.body = {
                        result: formattedValue,
                        variablesReference: 0
                    };
                    this.sendResponse(response);
                    this.serializer.endExec();
                });
                return;
            }
            // Check if it is a label. A label may have a special formatting:
            // Example: LBL_TEXT 10, b
            // = Addresse LBL_TEXT, 10 bytes
            const match = /^@?([^\s,]+)\s*(,\s*([^\s,]*))?(,\s*([^\s,]*))?/.exec(name);
            if (match) {
                let labelString = match[1];
                let sizeString = match[3];
                let byteWord = match[5];
                // Defaults
                if (labelString) {
                    let labelValue = NaN;
                    let lastLabel;
                    let modulePrefix;
                    // First check for module name and local label prefix (sjasmplus).
                    if (emulatorfactory_1.Emulator.RegisterCache) {
                        // Get current pc
                        const pc = z80Registers_1.Z80Registers.parsePC(emulatorfactory_1.Emulator.RegisterCache);
                        const entry = labels_1.Labels.getFileAndLineForAddress(pc);
                        // Local label and prefix
                        lastLabel = entry.lastLabel;
                        modulePrefix = entry.modulePrefix;
                    }
                    // Convert label
                    try {
                        labelValue = utility_1.Utility.evalExpression(labelString, false, modulePrefix, lastLabel);
                    }
                    catch (_a) { }
                    if (!isNaN(labelValue)) {
                        var size = 100;
                        if (sizeString) {
                            const readSize = labels_1.Labels.getNumberFromString(sizeString) || NaN;
                            if (!isNaN(readSize))
                                size = readSize;
                        }
                        if (!byteWord || byteWord.length == 0)
                            byteWord = "bw"; // both byte and word
                        // Now create a "variable" for the bigValues or small values
                        const format = (labelValue <= settings_1.Settings.launch.smallValuesMaximum) ? settings_1.Settings.launch.formatting.smallValues : settings_1.Settings.launch.formatting.bigValues;
                        utility_1.Utility.numberFormatted(name, labelValue, 2, format, undefined, (formattedValue) => {
                            if (labelValue <= settings_1.Settings.launch.smallValuesMaximum) {
                                // small value
                                // Response
                                response.body = {
                                    result: (args.context == 'hover') ? name + ': ' + formattedValue : formattedValue,
                                    variablesReference: 0,
                                };
                            }
                            else {
                                // big value
                                // Create a label variable
                                const labelVar = new shallowvar_1.LabelVar(labelValue, size, byteWord, this.listVariables);
                                // Add to list
                                const ref = this.listVariables.addObject(labelVar);
                                // Response
                                response.body = {
                                    result: (args.context == 'hover') ? name + ': ' + formattedValue : formattedValue,
                                    variablesReference: ref,
                                    type: "data",
                                    //presentationHint: ,
                                    namedVariables: 2,
                                };
                            }
                            ;
                            this.sendResponse(response);
                            this.serializer.endExec();
                        });
                        return;
                    }
                }
            }
            // Default: return nothing
            this.sendResponse(response);
            this.serializer.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  endExec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.log:  Main.CallSerializer:  exec: queue.size = 0
CallSerializer.log:  Main.CallSerializer: 
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // case asynchronously retrieve the register values.
            // Return registers only if 'name' itself is not a register.
            if (!z80Registers_1.Z80Registers.isRegister(name)) {
                emulatorfactory_1.Emulator.getRegisters(data => {
                    regsString = data;
                    cs.endExec();
                });
            }
            else
                cs.endExec();
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Check first if we need to retrieve address values
            const matchAddr = /(\${b@:|\${w@:)/.exec(format);
            if (matchAddr) {
                // Retrieve memory values
                zesaruxSocket_1.zSocket.send('read-memory ' + value + ' 2', data => {
                    const b1 = data.substr(0, 2);
                    const b2 = data.substr(2, 2);
                    const memByte = parseInt(b1, 16);
                    memWord = memByte + (parseInt(b2, 16) << 8);
                    cs.endExec();
                });
            }
            else {
                // End directly
                cs.endExec();
            }
        }
CallSerializer.exec:  Pushed (size=1, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
CallSerializer.endExec:  Popped (size=0, name=undefined), (cs) => {
            // Format
            var valString = this.numberFormattedSync(value, size, format, regsString, name, memWord, tabSizeArr);
            // Call handler with the result string
            handler(valString);
            // End
            cs.endExec();
        }
EmulDebugAdapter.dispatchRequest:  ->: disconnect({"restart":false})
EmulDebugAdapter.sendResponse:  <-: disconnect(undefined)
EmulDebugAdapter.exit:  Exit debugger!
EmulDebugAdapter.sendEvent:  <-: terminated(undefined)
